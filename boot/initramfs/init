#!/bin/sh
#
# Phase Boot - Init Script (PID 1)
#
# This is the first userspace process that runs when the Phase Boot
# initramfs is loaded by the kernel. It sets up the minimal environment
# needed to bootstrap the Phase network discovery system.
#

# Don't use set -e - handle errors gracefully
# set -e

#------------------------------------------------------------------------------
# Configuration & Defaults
#------------------------------------------------------------------------------

PHASE_VERSION="0.1.0-M3"
SCRIPTS_DIR="/scripts"
PHASE_MODE="internet"
PHASE_CHANNEL="stable"
PHASE_CACHE="true"
PHASE_NOWRITE="false"
PHASE_PROVIDER=""  # Direct provider URL (e.g., http://192.168.2.1:8080)

#------------------------------------------------------------------------------
# Mount Essential Filesystems
#------------------------------------------------------------------------------

mount_essential() {
    echo "Mounting essential filesystems..."

    # Create mount points if they don't exist
    [ -d /proc ] || mkdir -p /proc
    [ -d /sys ]  || mkdir -p /sys
    [ -d /dev ]  || mkdir -p /dev
    [ -d /run ]  || mkdir -p /run
    [ -d /tmp ]  || mkdir -p /tmp

    # /proc - Process information pseudo-filesystem
    mount -t proc proc /proc

    # /sys - Kernel and device information
    mount -t sysfs sysfs /sys

    # /dev - Device nodes (devtmpfs is auto-populated by kernel)
    mount -t devtmpfs devtmpfs /dev

    # /run - Runtime data (tmpfs, volatile)
    mount -t tmpfs -o nosuid,nodev,mode=0755 tmpfs /run

    # /tmp - Temporary files
    mount -t tmpfs -o nosuid,nodev tmpfs /tmp

    echo "Essential filesystems mounted."
}

#------------------------------------------------------------------------------
# Parse Kernel Command Line
#------------------------------------------------------------------------------

parse_cmdline() {
    echo "Parsing kernel command line..."

    # Read kernel command line
    if [ -f /proc/cmdline ]; then
        CMDLINE=$(cat /proc/cmdline)

        # Parse each parameter
        for param in $CMDLINE; do
            case "$param" in
                phase.mode=*)
                    PHASE_MODE="${param#phase.mode=}"
                    ;;
                phase.channel=*)
                    PHASE_CHANNEL="${param#phase.channel=}"
                    ;;
                phase.cache=*)
                    PHASE_CACHE="${param#phase.cache=}"
                    ;;
                phase.nowrite=*)
                    PHASE_NOWRITE="${param#phase.nowrite=}"
                    ;;
                phase.provider=*)
                    PHASE_PROVIDER="${param#phase.provider=}"
                    ;;
            esac
        done
    fi

    # Validate mode
    case "$PHASE_MODE" in
        internet|local|private)
            ;;
        *)
            echo "Warning: Unknown phase.mode=$PHASE_MODE, defaulting to 'internet'"
            PHASE_MODE="internet"
            ;;
    esac

    echo "Mode: $PHASE_MODE"
    [ -n "$PHASE_CHANNEL" ] && echo "Channel: $PHASE_CHANNEL"
    [ -n "$PHASE_PROVIDER" ] && echo "Provider: $PHASE_PROVIDER"
}

#------------------------------------------------------------------------------
# Set Up Console
#------------------------------------------------------------------------------

setup_console() {
    echo "Setting up console..."

    CONSOLE_DEV=""
    for dev in /dev/console /dev/tty0 /dev/ttyS0; do
        if [ -c "$dev" ]; then
            CONSOLE_DEV="$dev"
            break
        fi
    done

    # Bind stdin to a real console if available
    if [ -n "$CONSOLE_DEV" ]; then
        exec 0<"$CONSOLE_DEV"
    fi

    # Always append to log; mirror to console if present
    if [ -n "$CONSOLE_DEV" ]; then
        tail -f "$LOG_FILE" > "$CONSOLE_DEV" 2>/dev/null &
    fi
    exec >>"$LOG_FILE" 2>&1

    # Fallback stdin if no console was found
    if [ -z "$CONSOLE_DEV" ]; then
        exec 0</dev/null
    fi

    # Set up job control for the shell
    setsid sh -c 'exec sh </dev/console >/dev/console 2>&1' || true
}

#------------------------------------------------------------------------------
# Persist Logs to Boot Partition (best-effort)
#------------------------------------------------------------------------------

mount_boot_partition() {
    BOOT_MOUNT="/boot"
    mkdir -p "$BOOT_MOUNT"

    # Try multiple times in case the device appears late
    for attempt in 1 2 3 4 5; do
        # Preferred: by-label
        if [ -e /dev/disk/by-label/PHASEBOOT ]; then
            if mount -t vfat -o rw /dev/disk/by-label/PHASEBOOT "$BOOT_MOUNT" 2>/dev/null; then
                echo "Boot partition mounted at /dev/disk/by-label/PHASEBOOT (attempt $attempt)"
                return 0
            fi
        fi

        # Fallback scan of common USB devices
        for dev in /dev/sd[a-d][1-3]; do
            [ -e "$dev" ] || continue
            if mount -t vfat -o rw "$dev" "$BOOT_MOUNT" 2>/dev/null; then
                echo "Boot partition mounted at $dev (attempt $attempt)"
                return 0
            fi
        done

        sleep 1
    done

    echo "Boot partition not mounted (optional)."
    return 1
}

persist_logs_if_possible() {
    if grep -q " /boot " /proc/mounts 2>/dev/null; then
        echo "Persisting init log to /boot/phase-init.log"
        (
            while true; do
                cp /run/phase-init.log /boot/phase-init.log 2>/dev/null && sync
                sleep 2
            done
        ) &
    fi
}

#------------------------------------------------------------------------------
# Load Kernel Modules
#------------------------------------------------------------------------------

load_modules() {
    echo "Loading kernel modules..."

    # Load virtio modules for QEMU/VM networking (in dependency order)
    if [ -d /lib/modules ]; then
        KVER=$(uname -r)
        if [ -d "/lib/modules/$KVER" ]; then
            # Order matters: packet (for DHCP) -> virtio base -> pci helpers -> pci -> failover -> net
            for mod in af_packet virtio virtio_ring virtio_pci_modern_dev virtio_pci_legacy_dev virtio_pci failover net_failover virtio_net; do
                modpath=$(find /lib/modules/$KVER -name "${mod}.ko" 2>/dev/null | head -1)
                if [ -n "$modpath" ]; then
                    insmod "$modpath" 2>/dev/null && echo "  Loaded: $mod" || true
                fi
            done
        fi
    fi

    # Give devices time to appear
    sleep 2

    # Show available interfaces
    echo "Available interfaces:"
    ls /sys/class/net/ 2>/dev/null || echo "  (none)"
}

#------------------------------------------------------------------------------
# Network Initialization
#------------------------------------------------------------------------------

setup_network() {
    echo "Initializing network..."

    # Use modular network scripts if available
    if [ -x "$SCRIPTS_DIR/net-init.sh" ]; then
        echo "Using modular network initialization..."
        if "$SCRIPTS_DIR/net-init.sh"; then
            if [ -f /tmp/network.status ] && [ "$(cat /tmp/network.status)" = "up" ]; then
                NETWORK_STATUS="UP ($(cat /tmp/network.interface 2>/dev/null || echo 'unknown'))"
                NETWORK_IP=$(cat /tmp/network.ip 2>/dev/null || echo "unknown")
            else
                NETWORK_STATUS="DOWN"
            fi
        else
            NETWORK_STATUS="FAILED"
        fi
    else
        # Fallback to basic network initialization
        echo "Modular scripts not available, using basic initialization..."

        # Bring up loopback interface
        ip link set lo up 2>/dev/null || ifconfig lo up 2>/dev/null || {
            echo "Warning: Failed to bring up loopback interface"
        }

        # Find and configure network interfaces
        NETWORK_STATUS="No network configured"

        for iface in /sys/class/net/*; do
            iface=$(basename "$iface")
            [ "$iface" = "lo" ] && continue

            echo "Trying interface: $iface"
            ip link set "$iface" up 2>/dev/null || { echo "  Failed to bring up"; continue; }
            echo "  Interface up, requesting DHCP..."

            if command -v udhcpc >/dev/null 2>&1; then
                # Use explicit script path and longer timeout for DHCP
                UDHCPC_SCRIPT="/usr/share/udhcpc/default.script"
                if [ -x "$UDHCPC_SCRIPT" ]; then
                    UDHCPC_OPTS="-s $UDHCPC_SCRIPT"
                else
                    UDHCPC_OPTS=""
                fi
                if udhcpc -i "$iface" $UDHCPC_OPTS -t 5 -T 3 -n 2>&1; then
                    # Read IP from status file (set by default.script) or from interface
                    if [ -f /tmp/network.ip ]; then
                        NETWORK_IP=$(cat /tmp/network.ip)
                    else
                        NETWORK_IP=$(ip addr show "$iface" | grep 'inet ' | awk '{print $2}' | cut -d/ -f1)
                    fi
                    NETWORK_STATUS="DHCP on $iface ($NETWORK_IP)"
                    break
                else
                    echo "  DHCP failed on $iface"
                fi
            elif command -v dhcpcd >/dev/null 2>&1; then
                dhcpcd -q "$iface" 2>/dev/null && {
                    NETWORK_STATUS="DHCP on $iface"
                    break
                }
            fi
        done
    fi

    echo "Network: $NETWORK_STATUS"
}

#------------------------------------------------------------------------------
# Phase Discovery (M2+)
#------------------------------------------------------------------------------

run_discovery() {
    echo "Starting Phase discovery..."

    # Skip discovery in some cases
    if [ "$PHASE_MODE" = "local" ]; then
        echo "Local mode: Using mDNS discovery (if available)"
        DISCOVERY_METHOD="mdns"
    else
        echo "Using DHT discovery..."
        DISCOVERY_METHOD="dht"
    fi

    # Check for phase-discover binary
    if [ -x "/bin/phase-discover" ]; then
        echo "Running phase-discover..."

        # Build discovery arguments
        DISCOVER_ARGS="--arch $(uname -m) --channel ${PHASE_CHANNEL:-stable}"

        # Add ephemeral flag for private mode
        if [ "$PHASE_MODE" = "private" ]; then
            DISCOVER_ARGS="$DISCOVER_ARGS --ephemeral"
        fi

        # Run discovery with timeout
        if /bin/phase-discover $DISCOVER_ARGS --timeout 30 --quiet > /tmp/manifest_url 2>/dev/null; then
            MANIFEST_URL=$(cat /tmp/manifest_url)
            echo "Discovered manifest: $MANIFEST_URL"
            return 0
        else
            echo "Discovery failed or timed out"
            return 1
        fi
    else
        echo "phase-discover not available (M2 binary not installed)"
        echo "Skipping discovery - will drop to shell"
        return 1
    fi
}

#------------------------------------------------------------------------------
# Fetch from Provider and kexec
#------------------------------------------------------------------------------

fetch_and_boot() {
    PROVIDER_URL="$1"
    echo ""
    echo "=========================================="
    echo "  PHASE BOOT - Fetching from Provider"
    echo "=========================================="
    echo ""
    echo "Provider: $PROVIDER_URL"
    echo ""

    # Create download directory
    mkdir -p /tmp/phase-boot

    # Step 1: Fetch manifest
    echo "[1/4] Fetching manifest..."
    MANIFEST_URL="${PROVIDER_URL}/manifest.json"
    if ! wget -q -O /tmp/phase-boot/manifest.json "$MANIFEST_URL" 2>/dev/null; then
        echo "  FAILED: Could not fetch manifest from $MANIFEST_URL"
        return 1
    fi
    echo "  OK: Manifest downloaded"

    # Parse manifest for artifact URLs (simple parsing with grep/sed)
    # Look for kernel and initramfs download URLs
    KERNEL_PATH=$(grep -o '"download_url":"[^"]*kernel[^"]*"' /tmp/phase-boot/manifest.json | head -1 | sed 's/.*:"\([^"]*\)".*/\1/')
    INITRAMFS_PATH=$(grep -o '"download_url":"[^"]*initramfs[^"]*"' /tmp/phase-boot/manifest.json | head -1 | sed 's/.*:"\([^"]*\)".*/\1/')

    if [ -z "$KERNEL_PATH" ] || [ -z "$INITRAMFS_PATH" ]; then
        echo "  FAILED: Could not parse artifact URLs from manifest"
        cat /tmp/phase-boot/manifest.json
        return 1
    fi

    # Build full URLs
    KERNEL_URL="${PROVIDER_URL}${KERNEL_PATH}"
    INITRAMFS_URL="${PROVIDER_URL}${INITRAMFS_PATH}"

    echo "  Kernel URL: $KERNEL_URL"
    echo "  Initramfs URL: $INITRAMFS_URL"
    echo ""

    # Step 2: Download kernel
    echo "[2/4] Downloading kernel..."
    if ! wget -O /tmp/phase-boot/kernel "$KERNEL_URL" 2>&1; then
        echo "  FAILED: Could not download kernel"
        return 1
    fi
    KERNEL_SIZE=$(ls -lh /tmp/phase-boot/kernel | awk '{print $5}')
    echo "  OK: Kernel downloaded ($KERNEL_SIZE)"
    echo ""

    # Step 3: Download initramfs
    echo "[3/4] Downloading initramfs..."
    if ! wget -O /tmp/phase-boot/initramfs "$INITRAMFS_URL" 2>&1; then
        echo "  FAILED: Could not download initramfs"
        return 1
    fi
    INITRAMFS_SIZE=$(ls -lh /tmp/phase-boot/initramfs | awk '{print $5}')
    echo "  OK: Initramfs downloaded ($INITRAMFS_SIZE)"
    echo ""

    # Step 4: Verify downloads
    echo "[4/4] Verifying downloads..."
    if [ ! -s /tmp/phase-boot/kernel ] || [ ! -s /tmp/phase-boot/initramfs ]; then
        echo "  FAILED: Downloaded files are empty"
        return 1
    fi
    echo "  OK: Files verified"
    echo ""

    # Show what we downloaded
    echo "=========================================="
    echo "  Download Complete!"
    echo "=========================================="
    ls -lh /tmp/phase-boot/
    echo ""

    # Check for kexec
    if command -v kexec >/dev/null 2>&1; then
        echo "kexec available - preparing to boot into downloaded kernel..."
        echo ""

        # ARM64 requires the Device Tree Blob (DTB)
        # Copy FDT to a regular file and zero out kaslr-seed for kexec
        DTB_ARGS=""
        if [ -f /sys/firmware/fdt ]; then
            echo "Copying DTB from /sys/firmware/fdt..."
            cp /sys/firmware/fdt /tmp/phase-boot/device.dtb
            chmod 644 /tmp/phase-boot/device.dtb

            # Zero out kaslr-seed (kexec refuses non-zero kaslr-seed)
            if command -v fdtput >/dev/null 2>&1; then
                echo "Zeroing kaslr-seed in DTB (required for kexec)..."
                fdtput -t x /tmp/phase-boot/device.dtb /chosen kaslr-seed 0 0 2>/dev/null || \
                    echo "  Warning: Could not zero kaslr-seed"
            else
                echo "  Warning: fdtput not available, kaslr-seed not zeroed"
            fi

            DTB_ARGS="--dtb=/tmp/phase-boot/device.dtb"
            echo "  DTB size: $(ls -lh /tmp/phase-boot/device.dtb | awk '{print $5}')"
        fi

        # Try kexec -l (legacy syscall, proven to work on ARM64 Fedora)
        echo ""
        echo "Attempting kexec -l (legacy load)..."
        if kexec -l /tmp/phase-boot/kernel --initrd=/tmp/phase-boot/initramfs $DTB_ARGS --append="console=ttyAMA0 phase.mode=$PHASE_MODE" 2>&1; then
            echo "Kernel loaded successfully with kexec -l!"
            echo ""
            echo "=========================================="
            echo "  EXECUTING KEXEC - Booting new kernel!"
            echo "=========================================="
            sleep 2
            kexec -e
            # Should not reach here
            echo "ERROR: kexec -e failed!"
        else
            echo "kexec -l failed, trying kexec -s (file-based syscall)..."
            if kexec -s /tmp/phase-boot/kernel --initrd=/tmp/phase-boot/initramfs $DTB_ARGS --append="console=ttyAMA0 phase.mode=$PHASE_MODE" 2>&1; then
                echo "Kernel loaded with kexec -s!"
                echo ""
                echo "=========================================="
                echo "  EXECUTING KEXEC - Booting new kernel!"
                echo "=========================================="
                sleep 2
                kexec -e
                echo "ERROR: kexec -e failed!"
            else
                echo ""
                echo "=========================================="
                echo "  KEXEC FAILED - Manual debugging"
                echo "=========================================="
                echo ""
                echo "Both kexec methods failed. Debug info:"
                echo "  Kernel: $(ls -lh /tmp/phase-boot/kernel)"
                echo "  Initramfs: $(ls -lh /tmp/phase-boot/initramfs)"
                [ -f /tmp/phase-boot/device.dtb ] && echo "  DTB: $(ls -lh /tmp/phase-boot/device.dtb)"
                echo ""
                echo "Try manually:"
                echo "  kexec -d -l /tmp/phase-boot/kernel \\"
                echo "    --initrd=/tmp/phase-boot/initramfs \\"
                [ -n "$DTB_ARGS" ] && echo "    $DTB_ARGS \\"
                echo "    --append=\"console=ttyAMA0\""
                echo ""
                return 1
            fi
        fi
    else
        echo "=========================================="
        echo "  SUCCESS - Ready for kexec"
        echo "=========================================="
        echo ""
        echo "kexec not available in this initramfs."
        echo "Downloaded artifacts are ready at /tmp/phase-boot/"
        echo ""
        echo "To complete the boot (if kexec were available):"
        echo "  kexec -l /tmp/phase-boot/kernel \\"
        echo "    --initrd=/tmp/phase-boot/initramfs \\"
        echo "    --append=\"console=ttyAMA0 phase.mode=internet\""
        echo "  kexec -e"
        echo ""
        echo "For now, dropping to shell for inspection..."
        return 0
    fi
}

#------------------------------------------------------------------------------
# Print Boot Banner
#------------------------------------------------------------------------------

print_banner() {
    cat <<'EOF'

  ____  _                      ____              _
 |  _ \| |__   __ _ ___  ___  | __ )  ___   ___ | |_
 | |_) | '_ \ / _` / __|/ _ \ |  _ \ / _ \ / _ \| __|
 |  __/| | | | (_| \__ \  __/ | |_) | (_) | (_) | |_
 |_|   |_| |_|\__,_|___/\___| |____/ \___/ \___/ \__|

EOF

    echo "Phase Boot v$PHASE_VERSION"
    echo "================================"
    echo ""
    echo "Mode:    $PHASE_MODE"
    echo "Network: $NETWORK_STATUS"
    [ -n "$PHASE_CHANNEL" ] && echo "Channel: $PHASE_CHANNEL"
    echo ""
    echo "Configuration:"
    echo "  Cache:   $PHASE_CACHE"
    echo "  No-Write: $PHASE_NOWRITE"
    echo ""
    echo "--------------------------------"
    echo ""
    echo "Available commands:"
    echo "  ip addr          - Show network configuration"
    echo "  ip route         - Show routing table"
    echo "  mount            - Show mounted filesystems"
    echo "  ps               - Show running processes"
    echo "  cat /proc/cmdline - Show kernel command line"
    if [ -x "$SCRIPTS_DIR/net-diag.sh" ]; then
        echo "  $SCRIPTS_DIR/net-diag.sh - Network diagnostics"
    fi
    if [ -x "/bin/phase-discover" ]; then
        echo "  phase-discover   - Manual manifest discovery"
    fi
    echo ""
    echo "Phase Boot initialized."
    echo ""
}

#------------------------------------------------------------------------------
# Main Initialization Sequence
#------------------------------------------------------------------------------

main() {
    # Clear screen for clean boot
    clear 2>/dev/null || true

    echo "Phase Boot initializing..."
    echo ""

    # Execute initialization steps
    mount_essential
    echo ""

    # Initialize logging immediately (before modules/console)
    LOG_FILE="/run/phase-init.log"
    touch "$LOG_FILE" 2>/dev/null || true
    chmod 600 "$LOG_FILE" 2>/dev/null || true
    echo "[init] phase-init starting..." >> "$LOG_FILE"
    sync

    # Try to mount boot early so we can copy a first log snapshot even if we hang later
    mount_boot_partition
    if grep -q " /boot " /proc/mounts 2>/dev/null; then
        cp "$LOG_FILE" /boot/phase-init.log 2>/dev/null || true
        sync || true
    fi

    parse_cmdline
    echo ""

    load_modules
    echo ""

    setup_console
    echo ""

    # If boot is mounted, start periodic persistence after console attach
    persist_logs_if_possible
    echo ""

    # Background retry to mount boot (if not already) and start persistence
    (
        for i in 1 2 3 4 5; do
            if grep -q " /boot " /proc/mounts 2>/dev/null; then
                break
            fi
            mount_boot_partition
            sleep 1
        done
        if grep -q " /boot " /proc/mounts 2>/dev/null; then
            persist_logs_if_possible
        fi
    ) &

    setup_network
    echo ""

    # Check for direct provider URL first (phase.provider=URL)
    if [ -n "$PHASE_PROVIDER" ]; then
        echo "Direct provider specified: $PHASE_PROVIDER"
        echo ""
        if fetch_and_boot "$PHASE_PROVIDER"; then
            echo ""
            echo "Fetch completed successfully."
        else
            echo ""
            echo "Fetch failed - dropping to shell for debugging."
        fi
        print_banner
        echo "Starting interactive shell..."
        echo ""
        exec /bin/sh
    fi

    # Attempt Phase discovery (M2+) if no direct provider
    DISCOVERY_SUCCESS=false
    if [ "$NETWORK_STATUS" != "DOWN" ] && [ "$NETWORK_STATUS" != "FAILED" ]; then
        echo "Network available, attempting discovery..."
        if run_discovery; then
            DISCOVERY_SUCCESS=true
            echo ""
            echo "Discovery successful!"
            # Fetch from discovered provider
            if [ -n "$MANIFEST_URL" ]; then
                # Extract base URL from manifest URL
                DISCOVERED_PROVIDER=$(echo "$MANIFEST_URL" | sed 's|/manifest.json$||')
                if fetch_and_boot "$DISCOVERED_PROVIDER"; then
                    echo ""
                    echo "Fetch completed successfully."
                else
                    echo ""
                    echo "Fetch failed - dropping to shell."
                fi
            fi
        else
            echo ""
            echo "Discovery not available or failed."
        fi
    else
        echo "Network not available, skipping discovery."
    fi
    echo ""

    print_banner

    echo "Starting interactive shell..."
    echo ""

    # Execute shell as PID 1
    exec /bin/sh
}

#------------------------------------------------------------------------------
# Cleanup Handler (if we ever get here)
#------------------------------------------------------------------------------

cleanup() {
    echo ""
    echo "Phase Boot shutting down..."
    umount /run 2>/dev/null || true
    umount /dev 2>/dev/null || true
    umount /sys 2>/dev/null || true
    umount /proc 2>/dev/null || true
}

# Register cleanup handler
trap cleanup EXIT

# Run main initialization
main

# Should never reach here due to 'exec /bin/sh' in main()
echo "ERROR: Init script terminated unexpectedly"
exit 1
